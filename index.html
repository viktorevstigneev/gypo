<html lang="en">
  <head>
    <title>Amjs softbody rope demo</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <style>
      body {
        color: #333;
        margin: 0;
      }

      canvas {
        max-width: 100%;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <!-- <script src="https://cdn.jsdelivr.net/npm/ammo-node@1.0.0/ammo.min.js"></script> -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="ammo.js"></script>

    <script type="module">
      // Graphics variables
      let container;
      let camera, controls, scene, renderer;
      let textureLoader;
      const clock = new THREE.Clock();

      // Physics variables
      const gravityConstant = -9.8;
      let collisionConfiguration;
      let dispatcher;
      let broadphase;
      let solver;
      let softBodySolver;
      let physicsWorld;
      const rigidBodies = [];
      const margin = 0.05;
      let hinge;
      let rope;
      let transformAux1;

      let armMovement = 0;

      Ammo().then(function (AmmoLib) {
        Ammo = AmmoLib;

        init();
        animate();
      });

      function init() {
        initGraphics();

        initPhysics();

        createObjects();

        initInput();
      }

      function initGraphics() {
        container = document.getElementById("container");

        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          100
        );
        camera.position.z = 9;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x404040);

        camera.position.set(0, 0, 5);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);
        //OrbitControls
        controls = new THREE.OrbitControls(camera, renderer.domElement);

        textureLoader = new THREE.TextureLoader();

        const light = new THREE.PointLight(0xffffff, 3);
        light.position.set(0, 4, 5);

        scene.add(light);

        window.addEventListener("resize", onWindowResize);
      }

      function initPhysics() {
        // Physics configuration

        collisionConfiguration =
          new Ammo.btSoftBodyRigidBodyCollisionConfiguration();
        dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
        broadphase = new Ammo.btDbvtBroadphase();
        solver = new Ammo.btSequentialImpulseConstraintSolver();
        softBodySolver = new Ammo.btDefaultSoftBodySolver();
        physicsWorld = new Ammo.btSoftRigidDynamicsWorld(
          dispatcher,
          broadphase,
          solver,
          collisionConfiguration,
          softBodySolver
        );
        physicsWorld.setGravity(new Ammo.btVector3(0, gravityConstant, 0));
        physicsWorld
          .getWorldInfo()
          .set_m_gravity(new Ammo.btVector3(0, gravityConstant, 0));

        transformAux1 = new Ammo.btTransform();
      }

      function createObjects() {
        const pos = new THREE.Vector3();
        const quat = new THREE.Quaternion();

        const gltfLoader = new THREE.GLTFLoader();

        //house
        gltfLoader.load(
          "https://arweave.net/y92G01mL2GeNwmD-9R21-BSXN9QKeWkMWK73QcDZyGM",
          function (gltf) {
            const model = gltf.scene;
            scene.add(model);

            model.position.set(0, 0, 0);
            const boxWidth = 7.12;

            const diff = window.innerWidth / boxWidth;
            console.log("diff: ", diff / 50);
            console.log("window.innerHeight: ", window.innerHeight);

            model.scale.x = diff / 50;

            model.scale.z = diff / 40;

            const textureLoader = new THREE.TextureLoader();
            const texture = textureLoader.load(
              "https://arweave.net/XnXv1vZS_IW5UaoHzuTSxjntpu2XXNQKa3PAXEgBOCY"
            );

            model.traverse((child) => {
              if (child.isMesh) {
                child.material.map = texture;
                child.material.roughness = 0.7;
              }
            });
          }
        );

        // Ground
        pos.set(0, -0.5, 0);
        quat.set(0, 0, 0, 1);
        // const ground = createParalellepiped(
        //   40,
        //   1,
        //   40,
        //   0,
        //   pos,
        //   quat,
        //   new THREE.MeshPhongMaterial({ color: 0xffffff })
        // );
        // ground.castShadow = true;
        // ground.receiveShadow = true;
        // textureLoader.load("textures/grid.png", function (texture) {
        //   texture.colorSpace = THREE.SRGBColorSpace;
        //   texture.wrapS = THREE.RepeatWrapping;
        //   texture.wrapT = THREE.RepeatWrapping;
        //   texture.repeat.set(40, 40);
        //   ground.material.map = texture;
        //   ground.material.needsUpdate = true;
        // });

        // Ball
        const ballMass = 1.2;
        const ballRadius = 0.6;

        const ball = new THREE.Mesh(
          new THREE.SphereGeometry(ballRadius, 10, 10),
          new THREE.MeshPhongMaterial({ color: 0x202020 })
        );
        ball.castShadow = true;
        ball.receiveShadow = true;
        const ballShape = new Ammo.btSphereShape(ballRadius);
        ballShape.setMargin(margin);
        pos.set(0, -0.1, 0);
        quat.set(0, 0, 0, 1);
        createRigidBody(ball, ballShape, ballMass, pos, quat);
        ball.userData.physicsBody.setFriction(0.5);
        ball.visible = false;

        // // Wall
        const brickMass = 0.5;
        const brickLength = 1.2;
        const brickDepth = 0.6;
        const brickHeight = brickLength * 0.5;
        const numBricksLength = 6;
        const numBricksHeight = 8;
        const z0 = -numBricksLength * brickLength * 0.5;
        pos.set(0, brickHeight * 0.5, z0);
        quat.set(0, 0, 0, 1);

        // for (let j = 0; j < numBricksHeight; j++) {
        //   const oddRow = j % 2 == 1;

        //   pos.z = z0;

        //   if (oddRow) {
        //     pos.z -= 0.25 * brickLength;
        //   }

        //   const nRow = oddRow ? numBricksLength + 1 : numBricksLength;

        //   pos.y += brickHeight;
        // }

        // The rope
        // Rope graphic object
        const ropeNumSegments = 10;
        const ropeLength = 5;
        const ropeMass = 3;
        const ropePos = ball.position.clone();
        ropePos.y += ballRadius + 0.5;
        console.log("ropePos: ", ropePos);
        console.log("ballRadius: ", ballRadius);

        const segmentLength = ropeLength / ropeNumSegments;
        const ropeGeometry = new THREE.BufferGeometry();
        const ropeMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
        const ropePositions = [];
        const ropeIndices = [];

        for (let i = 0; i < ropeNumSegments + 1; i++) {
          ropePositions.push(
            ropePos.x,
            ropePos.y + i * segmentLength,
            ropePos.z
          );
        }

        for (let i = 0; i < ropeNumSegments; i++) {
          ropeIndices.push(i, i + 1);
        }

        ropeGeometry.setIndex(
          new THREE.BufferAttribute(new Uint16Array(ropeIndices), 1)
        );
        ropeGeometry.setAttribute(
          "position",
          new THREE.BufferAttribute(new Float32Array(ropePositions), 3)
        );
        ropeGeometry.computeBoundingSphere();
        rope = new THREE.LineSegments(ropeGeometry, ropeMaterial);
        rope.castShadow = true;
        rope.receiveShadow = true;
        scene.add(rope);

        // Rope physic object
        const softBodyHelpers = new Ammo.btSoftBodyHelpers();
        const ropeStart = new Ammo.btVector3(ropePos.x, ropePos.y, ropePos.z);
        const ropeEnd = new Ammo.btVector3(
          ropePos.x,
          ropePos.y + ropeLength,
          ropePos.z
        );
        const ropeSoftBody = softBodyHelpers.CreateRope(
          physicsWorld.getWorldInfo(),
          ropeStart,
          ropeEnd,
          ropeNumSegments - 1,
          0
        );
        const sbConfig = ropeSoftBody.get_m_cfg();
        sbConfig.set_viterations(10);
        sbConfig.set_piterations(10);
        ropeSoftBody.setTotalMass(ropeMass, false);
        Ammo.castObject(ropeSoftBody, Ammo.btCollisionObject)
          .getCollisionShape()
          .setMargin(margin * 3);
        physicsWorld.addSoftBody(ropeSoftBody, 1, -1);
        rope.userData.physicsBody = ropeSoftBody;
        // Disable deactivation
        ropeSoftBody.setActivationState(4);

        // The base
        const armMass = 2;
        const armLength = 3;
        const pylonHeight = ropePos.y + ropeLength;
        const baseMaterial = new THREE.MeshPhongMaterial({ color: 0x606060 });
        pos.set(ropePos.x, 0.1, ropePos.z - armLength);
        quat.set(0, 0, 0, 1);
        const base = createParalellepiped(
          1,
          0.2,
          1,
          0,
          pos,
          quat,
          baseMaterial
        );
        base.castShadow = true;
        base.receiveShadow = true;
        base.visible = false;
        pos.set(ropePos.x, 4, ropePos.z - armLength);
        const pylon = createParalellepiped(
          0.4,
          pylonHeight,
          0.4,
          0,
          pos,
          quat,
          baseMaterial
        );
        pylon.castShadow = true;
        pylon.receiveShadow = true;
        pylon.visible = false;
        pos.set(ropePos.x, pylonHeight + 0.2, ropePos.z - 0.5 * armLength);
        console.log("ropePos.x: ", ropePos.x);
        const arm = createParalellepiped(
          0.4,
          0.4,
          armLength + 0.4,
          armMass,
          pos,
          quat,
          baseMaterial
        );
        arm.castShadow = true;
        arm.receiveShadow = true;
        arm.visible = false;

        // Glue the rope extremes to the ball and the arm

        // medal
        gltfLoader.load(
          "https://arweave.net/FKvkcdR-cER9_gprxecqwa91S6haq1gvchJo5pEfK-c",
          function (gltf) {
            const model = gltf.scene;

            // model.position.x = 0;
            // model.position.y = 0;
            // model.castShadow = true;

            model.scale.x = 0.5;
            model.scale.z = 0.5;
            model.scale.y = 0.5;
            scene.add(model);
            console.log("model: ", model);

            pos.set(0, 2, 0);
            createRigidBody(model, ballShape, ballMass, pos, quat);
            model.userData.physicsBody.setFriction(0.5);

            const influence = 1;
            ropeSoftBody.appendAnchor(
              0,
              model.userData.physicsBody,
              true,
              influence
            );
          }
        );

        const influence = 1;
        // ropeSoftBody.appendAnchor(
        //   0,
        //   ball.userData.physicsBody,
        //   true,
        //   influence
        // );
        ropeSoftBody.appendAnchor(
          ropeNumSegments,
          arm.userData.physicsBody,
          true,
          influence
        );

        window.addEventListener("deviceorientation", (event) => {
          var beta = Math.floor(event.beta); // Угол наклона по оси X
          var gamma = Math.floor(event.gamma); // Угол наклона по оси Y
          var alpha = Math.floor(event.alpha); // Угол наклона по оси Z

          armMovement = gamma / 100;
        });

        // Hinge constraint to move the arm
        const pivotA = new Ammo.btVector3(0, pylonHeight * 0.5, 0);
        const pivotB = new Ammo.btVector3(0, -0.2, -armLength * 0.5);
        const axis = new Ammo.btVector3(0, 1, 0);
        hinge = new Ammo.btHingeConstraint(
          pylon.userData.physicsBody,
          arm.userData.physicsBody,
          pivotA,
          pivotB,
          axis,
          axis,
          true
        );
        physicsWorld.addConstraint(hinge, true);
      }

      function createParalellepiped(sx, sy, sz, mass, pos, quat, material) {
        const threeObject = new THREE.Mesh(
          new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1),
          material
        );
        const shape = new Ammo.btBoxShape(
          new Ammo.btVector3(sx * 0.5, sy * 0.5, sz * 0.5)
        );
        shape.setMargin(margin);

        createRigidBody(threeObject, shape, mass, pos, quat);

        return threeObject;
      }

      function createRigidBody(threeObject, physicsShape, mass, pos, quat) {
        threeObject.position.copy(pos);
        threeObject.quaternion.copy(quat);

        const transform = new Ammo.btTransform();
        transform.setIdentity();
        transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
        transform.setRotation(
          new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w)
        );
        const motionState = new Ammo.btDefaultMotionState(transform);

        const localInertia = new Ammo.btVector3(0, 0, 0);
        physicsShape.calculateLocalInertia(mass, localInertia);

        const rbInfo = new Ammo.btRigidBodyConstructionInfo(
          mass,
          motionState,
          physicsShape,
          localInertia
        );
        const body = new Ammo.btRigidBody(rbInfo);

        threeObject.userData.physicsBody = body;

        scene.add(threeObject);

        if (mass > 0) {
          rigidBodies.push(threeObject);

          // Disable deactivation
          body.setActivationState(4);
        }

        physicsWorld.addRigidBody(body);
      }

      function initInput() {
        window.addEventListener("keydown", function (event) {
          switch (event.keyCode) {
            // Q
            case 81:
              armMovement = 1;
              break;

            // A
            case 65:
              armMovement = -1;
              break;
          }
        });

        window.addEventListener("keyup", function () {
          armMovement = 0;
        });
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        render();
      }

      function render() {
        const deltaTime = clock.getDelta();

        updatePhysics(deltaTime);

        renderer.render(scene, camera);
      }

      function updatePhysics(deltaTime) {
        // Hinge control
        hinge.enableAngularMotor(true, 1.5 * armMovement, 50);

        // Step world
        physicsWorld.stepSimulation(deltaTime, 10);

        // Update rope
        const softBody = rope.userData.physicsBody;
        const ropePositions = rope.geometry.attributes.position.array;
        const numVerts = ropePositions.length / 3;
        const nodes = softBody.get_m_nodes();
        let indexFloat = 0;

        for (let i = 0; i < numVerts; i++) {
          const node = nodes.at(i);
          const nodePos = node.get_m_x();
          ropePositions[indexFloat++] = nodePos.x();
          ropePositions[indexFloat++] = nodePos.y();
          ropePositions[indexFloat++] = nodePos.z();
        }

        rope.geometry.attributes.position.needsUpdate = true;

        // ball.position;

        // Update rigid bodies
        for (let i = 0, il = rigidBodies.length; i < il; i++) {
          const objThree = rigidBodies[i];
          const objPhys = objThree.userData.physicsBody;
          const ms = objPhys.getMotionState();
          if (ms) {
            ms.getWorldTransform(transformAux1);
            const p = transformAux1.getOrigin();
            const q = transformAux1.getRotation();
            objThree.position.set(p.x(), p.y(), p.z());
            objThree.quaternion.set(q.x(), q.y(), q.z(), q.w());
          }
        }
      }
    </script>
  </body>
</html>
