<html lang="en">
  <head>
    <title>Amjs softbody rope demo</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <style>
      body {
        color: #333;
        margin: 0;
      }

      canvas {
        max-width: 100%;
      }

      .text {
        position: absolute;
        font-size: 19px;
      }

      .loader {
        background: #fff;
        width: 100%;
        height: 100%;
      }

      #main {
        height: 40px;
        width: 40px;
        background: indianred;
        border-radius: 100%;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 100;
      }

      .d {
        background: #fff;
        height: 14px;
        width: 14px;
        border-radius: 100%;
        position: absolute;
        margin: auto;
      }

      .ball-one {
        top: 0;
        left: 0;
        right: 65px;
        bottom: 65px;
        animation: anim 2s infinite ease-in;
      }

      @keyframes anim {
        0% {
          background: skyblue;
          right: 65px;
          bottom: 65px;
          z-index: 150;
        }
        33% {
          right: -65px;
          bottom: -65px;
        }
        66% {
          width: 10px;
          height: 10px;
        }
        99% {
          right: 65px;
          bottom: 65px;
          height: 14px;
          width: 14px;
          z-index: 0;
        }
        100% {
          background: skyblue;
        }
      }

      .ball-two {
        top: 0;
        right: 0;
        left: 65px;
        bottom: 65px;
        animation: anim-two 2s infinite ease-in;
        animation-delay: 0.4s;
      }

      @keyframes anim-two {
        0% {
          background: skyblue;
          left: 65px;
          bottom: 65px;
          z-index: 150;
        }
        33% {
          left: -65px;
          bottom: -65px;
        }
        66% {
          width: 10px;
          height: 10px;
        }
        99% {
          left: 65px;
          bottom: 65px;
          height: 14px;
          width: 14px;
          z-index: 0;
        }
        100% {
          background: skyblue;
        }
      }

      .ball-three {
        top: -65px;
        right: 0;
        left: 0;
        bottom: 0;
        animation: anim-three 2s infinite ease-in;
        animation-delay: 0.8s;
      }

      @keyframes anim-three {
        0% {
          background: skyblue;
          top: -65px;
          z-index: 150;
        }
        33% {
          top: 65px;
        }
        66% {
          width: 10px;
          height: 10px;
        }
        99% {
          top: -65px;
          height: 14px;
          width: 14px;
          z-index: 0;
        }
        100% {
          background: skyblue;
        }
      }
    </style>
  </head>

  <!-- let maxAcceleration = 0.2; // Максимальное ускорение, можно настроить под свои потребности
  let dampingFactor = 1; // Фактор затухания, можно настроить под свои потребности
  let idleThreshold = 3000; // Порог бездействия, например, 3 секунды -->

  <body>
    <div hidden class="setting">
      <!-- Максимальное ускорение, можно настроить под свои потребности -->
      <div class="scene__maxAcceleration" data-setting="0.2"></div>

      <!-- Фактор затухания, можно настроить под свои потребности -->
      <div class="scene__dampingFactor" data-setting="1"></div>

       <!-- Порог бездействия, например, 3 секунды -->
       <div class="scene__idleThreshold" data-setting="3000"></div>

      <div
        class="path__scr"
        data-setting="https://arweave.net/*******************************************"
      ></div>
      <div
        class="path__?"
        data-setting="https://arweave.net/*******************************************"
      ></div>
      <div
        class="path__draco"
        data-setting="https://ipfs.io/ipfs/QmRtxmQ8198Fk17MUkyPDpfCkXFdERbzLzRgLEPHwFLbLB/draco/"
      ></div>

      <div class="user_setting">
        <div class="us_name" data-setting="text"></div>
        <div
          class="us_logo"
          data-setting="https://arweave.net/0GLLxZ01jO4YUpFS85ItdiVuDEo7GfBwZF3dBT3JeuI"
        ></div>
        <div class="us_desc" data-setting="text"></div>
        <!-- Описание -->
      </div>

      <div class="scene_setting">
        <div class="ss_name" data-setting="text"></div>
        <div class="ss_advmsg" data-setting="text"></div>
        <!-- Текстовый информационный блок -->
        <div
          class="ss_envmap"
          data-setting="https://arweave.net/hm24jwn7B_MlzIZgdhV0jEiqMyT3bydaaMoEMD5jnFo"
        ></div>
        <div class="ss_envstrength" data-setting="1"></div>
        <!-- Сила освещения -->
        <div class="ss_gravity" data-setting="9,80665"></div>

        <div
          class="ss_box_mesh"
          data-setting="https://arweave.net/y92G01mL2GeNwmD-9R21-BSXN9QKeWkMWK73QcDZyGM"
        ></div>
        <div
          class="ss_box_albedo"
          data-setting="https://arweave.net/XnXv1vZS_IW5UaoHzuTSxjntpu2XXNQKa3PAXEgBOCY"
        ></div>
        <div
          class="ss_box_normal"
          data-setting="https://arweave.net/gyu2KWDSa-CMhBnExzbARhMxYENJcS9fDMhS__thP5M"
        ></div>
        <div
          class="ss_box_roughness"
          data-setting="https://arweave.net/dM-nwPlJ38TdOgPJgbjJn44KzZLQBdsgG7u02onAAxc"
        ></div>
        <div class="ss_box_metalness" data-setting=""></div>
        <!-- https://arweave.net/ -->
        <div class="ss_box_density" data-setting="0.5"></div>
        <div class="ss_box_mass" data-setting="10"></div>
        <div class="ss_box_st_friction" data-setting="0.3"></div>
        <div class="ss_box_dyn_friction" data-setting="0.3"></div>
        <div class="ss_box_bounciness" data-setting="0.5"></div>

        <div
          class="ss_medal_mesh"
          data-setting="https://arweave.net/FKvkcdR-cER9_gprxecqwa91S6haq1gvchJo5pEfK-c"
        ></div>
        <div
          class="ss_medal_albedo"
          data-setting="https://arweave.net/3-XKeM0kOxIrq6C0OCEBkoWprrUEmCxGfnqhrmhU0fM"
        ></div>
        <div
          class="ss_medal_normal"
          data-setting="https://arweave.net/PiK-P_5qNexb54MsL-BQMxBXf2Rersubc0CX65U7QyM"
        ></div>
        <div
          class="ss_medal_roughness"
          data-setting="https://arweave.net/_Nf5rrCBRbVdcW2IfTJG97MajxPQmTHr4pzgACJ51Ik"
        ></div>
        <div class="ss_medal_metalness" data-setting=""></div>
        <!-- https://arweave.net/ -->
        <div class="ss_medal_density" data-setting="0.5"></div>
        <div class="ss_medal_mass" data-setting="10"></div>
        <div class="ss_medal_st_friction" data-setting="0.3"></div>
        <div class="ss_medal_dyn_friction" data-setting="0.3"></div>
        <div class="ss_medal_bounciness" data-setting="0.5"></div>

        <div
          class="ss_rope_albedo"
          data-setting="https://arweave.net/XdR3tA31mfbhtjEgdklD9wA9pTHRu2-15F7wmoE42k4"
        ></div>
        <!--  -->
      </div>

      <div class="model-1">
        <div
          class="m1_mesh"
          data-setting="https://arweave.net/2xrlQq353EY494Q1MEty8OVZJOyQw-otkSvd1iOwXZY"
        ></div>
        <!-- kPgptTtGBhJdGUCYj1bToKX6EO1s3GrkAOObauEJAc8 -->
        <div
          class="m1_albedo"
          data-setting="https://arweave.net/_YEzL8T9lK0ty5EQ7nECVUEBNSIcMXLH9J0Y8rXFynw"
        ></div>
        <div
          class="m1_normal"
          data-setting="https://arweave.net/lGDYsR6RbgUkmL6KHhs4GyozbyvI2YVmtDXpu_suce8"
        ></div>
        <div
          class="m1_roughness"
          data-setting="https://arweave.net/giGKRY_xr0M0Uwj7MUtlrLz3vuV-zfkUq1IfgeqFzqo"
        ></div>
        <div class="m1_metalness" data-setting=""></div>
        <!-- https://arweave.net/ -->
        <div class="m1_density" data-setting="0.5"></div>
        <div class="m1_mass" data-setting="10"></div>
        <div class="m1_st_friction" data-setting="0.3"></div>
        <div class="m1_dyn_friction" data-setting="0.3"></div>
        <div class="m1_bounciness" data-setting="0.5"></div>
      </div>

      <div class="model-2">
        <div
          class="m2_mesh"
          data-setting="https://arweave.net/YGIqWc0EN9SZHctlt9JechCmIP_AC3Y5MKkqQsqFxyA"
        ></div>
        <!-- eYbVULjW7dryto_obr7jJnYVf7YqrjboGnDZZyBQhxk -->
        <div
          class="m2_albedo"
          data-setting="https://arweave.net/Hfw75Pyvd8Iv51y0cp8pdfqBigJvdfv8qQMxYbi8480"
        ></div>
        <div class="m2_normal" data-setting=""></div>
        <!-- Игнорировать, если отсутствует -->
        <div
          class="m2_roughness"
          data-setting="https://arweave.net/mo1LcZjeSWPXQeDYm5fplpK-FOyjOuJslFW8XDczSi4"
        ></div>
        <div class="m2_metalness" data-setting=""></div>
        <!-- https://arweave.net/ -->
        <div class="m2_density" data-setting="0.5"></div>
        <div class="m2_mass" data-setting="10"></div>
        <div class="m2_st_friction" data-setting="0.3"></div>
        <div class="m2_dyn_friction" data-setting="0.3"></div>
        <div class="m2_bounciness" data-setting="0.5"></div>
      </div>

      <div class="model-N">
        <div
          class="mN_mesh"
          data-setting="https://arweave.net/*******************************************"
        ></div>
        <div
          class="mN_albedo"
          data-setting="https://arweave.net/*******************************************"
        ></div>
        <div
          class="mN_normal"
          data-setting="https://arweave.net/*******************************************"
        ></div>
        <div
          class="mN_roughness"
          data-setting="https://arweave.net/*******************************************"
        ></div>
        <div class="mN_metalness" data-setting=""></div>
        <!-- https://arweave.net/ -->
        <div class="mN_density" data-setting="0.5"></div>
        <div class="mN_mass" data-setting="10"></div>
        <div class="mN_st_friction" data-setting="0.3"></div>
        <div class="mN_dyn_friction" data-setting="0.3"></div>
        <div class="mN_bounciness" data-setting="0.5"></div>
      </div>
    </div>
    <div class="loader">
      <div id="main" class="d"></div>
      <div class="ball-one d"></div>
      <div class="ball-two d"></div>
      <div class="ball-three d"></div>
    </div>
    <div id="container"></div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <!-- <script src="https://cdn.jsdelivr.net/npm/ammo-node@1.0.0/ammo.min.js"></script> -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script> -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="ammo.js"></script>

    <script type="module">
      setTimeout(() => {
        document.querySelector(".loader").style.display = "none";
      }, 3000);

      // Graphics variables
      let container;
      let camera, controls, scene, renderer;
      let textureLoader;
      const clock = new THREE.Clock();

      const gvSetting = document.querySelector(".ss_gravity").dataset.setting;

      // Physics variables
      const gravityConstant = -parseFloat(gvSetting);

      let collisionConfiguration;
      let dispatcher;
      let broadphase;
      let solver;
      let softBodySolver;
      let physicsWorld;
      const rigidBodies = [];
      const margin = 0.05;
      let hinge;
      let rope;
      let transformAux1;
      let medal;
      let medalBody;
      let house;

      let m1Body;
      let m2Body;

      Ammo().then(function (AmmoLib) {
        Ammo = AmmoLib;

        init();
        animate();
      });

      function init() {
        initGraphics();

        initPhysics();

        createObjects();

        initInput();
      }

      // ---------------------------- INIT GRAPHICS -----------------------------

      function initGraphics() {
        container = document.getElementById("container");

        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.9,
          100
        );

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x404040);

        camera.position.set(0, 0, 8);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);
        //OrbitControls
        // controls = new THREE.OrbitControls(camera, renderer.domElement);

        textureLoader = new THREE.TextureLoader();

        const light = new THREE.PointLight(0xffffff, 3);
        light.position.set(0, 4, 5);

        scene.add(light);
      }

      // ----------------------------------------INIT PHISICS--------------------------------------------
      function initPhysics() {
        // Physics configuration

        collisionConfiguration =
          new Ammo.btSoftBodyRigidBodyCollisionConfiguration();
        dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
        broadphase = new Ammo.btDbvtBroadphase();
        solver = new Ammo.btSequentialImpulseConstraintSolver();
        softBodySolver = new Ammo.btDefaultSoftBodySolver();
        physicsWorld = new Ammo.btSoftRigidDynamicsWorld(
          dispatcher,
          broadphase,
          solver,
          collisionConfiguration,
          softBodySolver
        );
        physicsWorld.setGravity(new Ammo.btVector3(0, gravityConstant, 0));
        physicsWorld
          .getWorldInfo()
          .set_m_gravity(new Ammo.btVector3(0, gravityConstant, 0));

        transformAux1 = new Ammo.btTransform();
      }

      // ------------------------------------------------CREATE OBJECTS -----------------------------
      async function createObjects() {
        function loadModel(url) {
          return new Promise((resolve, reject) => {
            gltfLoader.load(url, (loadedModel) => {
              resolve(loadedModel);
            });
          });
        }

        const pos = new THREE.Vector3();
        const quat = new THREE.Quaternion();

        const gltfLoader = new THREE.GLTFLoader();

        // ------------------------------------------------Model 2--------------------------
        let m2 = await loadModel(
          document.querySelector(".m2_mesh").dataset.setting
        );

        m2.scene.scale.x = 0.5;
        m2.scene.scale.y = 0.5;
        m2.scene.scale.z = 0.5;

        m2.scene.position.set(window.innerWidth / 200, 1, -1);
        scene.add(m2.scene);

        const m2Shape = new Ammo.btSphereShape(0.5);
        m2Shape.setMargin(margin);
        pos.set(window.innerWidth / 200, 0, -2);
        quat.set(0, 0, 0, 1);

        createRigidBody(m2.scene, m2Shape, 1, pos, quat, false, false, true);

        // // ------------------------------------------------Model 1--------------------------
        let m1 = await loadModel(
          document.querySelector(".m1_mesh").dataset.setting
        );

        m1.scene.scale.x = 0.5;
        m1.scene.scale.y = 0.5;
        m1.scene.scale.z = 0.5;

        m1.scene.position.set(-window.innerWidth / 200, -2, -0.5);
        scene.add(m1.scene);

        const m1Shape = new Ammo.btSphereShape(0.5);
        m1Shape.setMargin(margin);
        pos.set(-window.innerWidth / 200, -2, -0.5);
        quat.set(0, 0, 0, 1);

        createRigidBody(m1.scene, m1Shape, 1, pos, quat, false, true);

        // ------------------------------------------MEDAL -------------------
        const medalMass = 25.2;
        const medalRadius = 3.3;

        medal = await loadModel(
          document.querySelector(".ss_medal_mesh").dataset.setting
        );

        medal.castShadow = true;
        medal.receiveShadow = true;
        const medalShape = new Ammo.btSphereShape(medalRadius);
        medalShape.setMargin(margin);
        pos.set(0, 0, 0);
        quat.set(0, 0, 0, 1);

        createRigidBody(medal.scene, medalShape, medalMass, pos, quat, true);
        medal.scene.scale.x = 0.635;
        medal.scene.scale.y = 0.635;
        medal.scene.scale.z = 0.635;
        medal.scene.userData.physicsBody.setFriction(0.5);
        console.log("medal: ", medalBody && medalBody);

        // -------------------------------- HOUSE -----------------------------------------------

        const textureLoader = new THREE.TextureLoader();
        const texture = textureLoader.load(
          document.querySelector(".ss_box_albedo").dataset.setting
        );

        house = await loadModel(
          document.querySelector(".ss_box_mesh").dataset.setting
        );

        house.scene.traverse((child) => {
          if (child.isMesh) {
            child.material.map = texture;
          }
        });

        const boxWidth = 7.12;
        const diff = window.innerWidth / boxWidth;
        house.scene.scale.x = diff / 50;
        house.scene.scale.z = diff / 40;

        scene.add(house.scene);

        // ------------------------------------------------ROPE----------------------------------------
        const ropeNumSegments = 10;
        const ropeLength = 5;
        const ropeMass = 3;
        const ropePos = medal.scene.position.clone();
        console.log("ropePos: ", ropePos);
        ropePos.y += medalRadius - 2;

        const segmentLength = ropeLength / ropeNumSegments;
        const ropeGeometry = new THREE.BufferGeometry();
        const ropeMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
        const ropePositions = [];
        const ropeIndices = [];

        for (let i = 0; i < ropeNumSegments + 1; i++) {
          ropePositions.push(
            ropePos.x,
            ropePos.y + i * segmentLength,
            ropePos.z
          );
        }

        for (let i = 0; i < ropeNumSegments; i++) {
          ropeIndices.push(i, i + 1);
        }

        ropeGeometry.setIndex(
          new THREE.BufferAttribute(new Uint16Array(ropeIndices), 1)
        );
        ropeGeometry.setAttribute(
          "position",
          new THREE.BufferAttribute(new Float32Array(ropePositions), 3)
        );
        ropeGeometry.computeBoundingSphere();
        rope = new THREE.LineSegments(ropeGeometry, ropeMaterial);
        rope.castShadow = true;
        rope.receiveShadow = true;
        scene.add(rope);

        // -----------------------------------------ROPE PHISICS ------------------
        const softBodyHelpers = new Ammo.btSoftBodyHelpers();
        const ropeStart = new Ammo.btVector3(ropePos.x, ropePos.y, ropePos.z);
        const ropeEnd = new Ammo.btVector3(
          ropePos.x,
          ropePos.y + ropeLength,
          ropePos.z
        );
        const ropeSoftBody = softBodyHelpers.CreateRope(
          physicsWorld.getWorldInfo(),
          ropeStart,
          ropeEnd,
          ropeNumSegments - 1,
          0
        );
        const sbConfig = ropeSoftBody.get_m_cfg();
        sbConfig.set_viterations(10);
        sbConfig.set_piterations(10);
        ropeSoftBody.setTotalMass(ropeMass, false);
        Ammo.castObject(ropeSoftBody, Ammo.btCollisionObject)
          .getCollisionShape()
          .setMargin(margin * 3);
        physicsWorld.addSoftBody(ropeSoftBody, 1, -1);
        rope.userData.physicsBody = ropeSoftBody;
        // Disable deactivation
        ropeSoftBody.setActivationState(4);

        // ------------------------- BORDERS --------------------------------------
        pos.set(0, -5.5, 0);
        quat.set(0, 0, 0, 1);
        const ground = createParalellepiped(
          40,
          0.1,
          40,
          0,
          pos,
          quat,
          new THREE.MeshPhongMaterial({ color: 0xffffff })
        );

        pos.set(0, 7, 0);
        quat.set(0, 0, 0, 1);
        const ground1 = createParalellepiped(
          20,
          0.1,
          20,
          0,
          pos,
          quat,
          new THREE.MeshPhongMaterial({ color: 0xffffff })
        );

        pos.set(0, 0, -7);
        quat.set(0.7, 0, 0, 1);
        const ground2 = createParalellepiped(
          20,
          0.1,
          20,
          0,
          pos,
          quat,
          new THREE.MeshPhongMaterial({ color: 0xffffff })
        );

        pos.set(-window.innerWidth / 7.12 / 11, 0, 0);
        quat.set(0, 0, -0.7, 1);
        const ground3 = createParalellepiped(
          20,
          0.1,
          20,
          0,
          pos,
          quat,
          new THREE.MeshPhongMaterial({ color: 0xffffff })
        );

        pos.set(window.innerWidth / 7.12 / 11, 0, 0);
        quat.set(0, 0, 0.7, 1);
        const ground4 = createParalellepiped(
          20,
          0.1,
          20,
          0,
          pos,
          quat,
          new THREE.MeshPhongMaterial({ color: 0xffffff })
        );

        pos.set(0, -5, 0);
        quat.set(0.7, 0, 0, 1);
        const ground5 = createParalellepiped(
          20,
          0.1,
          1,
          0,
          pos,
          quat,
          new THREE.MeshPhongMaterial({ color: 0xffffff })
        );

        ground.visible = false;
        ground1.visible = false;
        ground2.visible = false;
        ground3.visible = false;
        ground4.visible = false;
        ground5.visible = false;

        // ----------------------------------UP POINT -----------------------------------

        function createParalellepiped(sx, sy, sz, mass, pos, quat, material) {
          const threeObject = new THREE.Mesh(
            new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1),
            material
          );
          const shape = new Ammo.btBoxShape(
            new Ammo.btVector3(sx * 0.5, sy * 0.5, sz * 0.5)
          );
          shape.setMargin(margin);

          createRigidBody(threeObject, shape, mass, pos, quat);

          return threeObject;
        }

        const baseMaterial = new THREE.MeshPhongMaterial({ color: 0x606060 });

        const arm = createParalellepiped(0, 0, 0, 0, pos, quat, baseMaterial);

        // arm.castShadow = true;
        // arm.receiveShadow = true;
        // arm.visible = false;

        //---------------------------------------CONNECTING OBJ-----------------------------------------
        const influence = 1;

        ropeSoftBody.appendAnchor(
          0,
          medal.scene.userData.physicsBody,
          true,
          influence
        );
        ropeSoftBody.appendAnchor(
          ropeNumSegments,
          arm.userData.physicsBody,
          true,
          influence
        );

        // --------------------------------------------HOUSE AND ARM ------------------------------------------
        // const pivotA = new Ammo.btVector3(0,  0.5, 0);
        // const pivotB = new Ammo.btVector3(0, -0.2, - 0.5);
        // const axis = new Ammo.btVector3(0, 1, 0);
        // hinge = new Ammo.btHingeConstraint(
        //   pylon.userData.physicsBody,
        //   arm.userData.physicsBody,
        //   pivotA,
        //   pivotB,
        //   axis,
        //   axis,
        //   true
        // );
        // physicsWorld.addConstraint(hinge, true);
      }

      function createRigidBody(
        threeObject,
        physicsShape,
        mass,
        pos,
        quat,
        isModel,
        isM1,
        isM2
      ) {
        threeObject.position.copy(pos);
        threeObject.quaternion.copy(quat);

        const transform = new Ammo.btTransform();
        transform.setIdentity();
        transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
        transform.setRotation(
          new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w)
        );
        const motionState = new Ammo.btDefaultMotionState(transform);

        const localInertia = new Ammo.btVector3(0, 0, 0);
        physicsShape.calculateLocalInertia(mass, localInertia);

        const rbInfo = new Ammo.btRigidBodyConstructionInfo(
          mass,
          motionState,
          physicsShape,
          localInertia
        );
        const body = new Ammo.btRigidBody(rbInfo);

        threeObject.userData.physicsBody = body;

        scene.add(threeObject);

        if (mass > 0) {
          rigidBodies.push(threeObject);

          // Disable deactivation
          body.setActivationState(4);
        }

        physicsWorld.addRigidBody(body);

        if (isModel) {
          medalBody = body;
        }

        if (isM1) {
          m1Body = body;
        }
        if (isM2) {
          m2Body = body;
        }
      }

      function initInput() {
        // Инициализация переменных для скользящего среднего
        let averageAcceleration = new Ammo.btVector3(0, 0, 0);
        let maxAcceleration = +(document.querySelector('.scene__maxAcceleration').dataset.setting); // Максимальное ускорение, можно настроить под свои потребности
    

        // document.querySelector('.scene_averageAcceleration').dataset.setting
        let dampingFactor = +(document.querySelector('.scene__dampingFactor').dataset.setting); // Фактор затухания, можно настроить под свои потребности
     

        // Инициализация переменных
        let initialPosition = new Ammo.btVector3(0, 0, 0); // Предположим, что изначальное положение медали находится в центре (0, 0, 0)
        let idleThreshold = +(document.querySelector('.scene__idleThreshold').dataset.setting); // Порог бездействия, например, 3 секунды
       
        let lastActivityTime = Date.now(); // Время последнего действия

        window.addEventListener("deviceorientation", (event) => {
          let gyroscopeData = {
            alpha: event.alpha,
            beta: event.beta,
            gamma: event.gamma,
          };

          // Применение скользящего среднего
          var newAcceleration = new Ammo.btVector3(
            gyroscopeData.gamma,
            gyroscopeData.alpha,
            gyroscopeData.beta
          );
          averageAcceleration.op_mul(dampingFactor);
          averageAcceleration.op_add(newAcceleration);

          // Ограничение максимального ускорения
          if (averageAcceleration.length() > maxAcceleration) {
            averageAcceleration.op_mul(
              maxAcceleration / averageAcceleration.length()
            );
          }

          // Применение ускорения к медали
          var currentVelocity = medalBody?.getLinearVelocity();
          var newVelocity = new Ammo.btVector3(
            currentVelocity?.x() + averageAcceleration.x(),
            currentVelocity?.y(),
            currentVelocity?.z() + averageAcceleration.z()
          );
          medalBody.setLinearVelocity(newVelocity);

          // Применение ускорения к м1
          var currentVelocity1 = m1Body?.getLinearVelocity();
          var newVelocity1 = new Ammo.btVector3(
            currentVelocity1?.x() + averageAcceleration.x(),
            currentVelocity1?.y(),
            currentVelocity1?.z() + averageAcceleration.z()
          );
          m1Body.setLinearVelocity(newVelocity1);

          // Применение ускорения к м2
          var currentVelocity2 = m2Body?.getLinearVelocity();
          var newVelocity2 = new Ammo.btVector3(
            currentVelocity2?.x() + averageAcceleration.x(),
            currentVelocity2?.y(),
            currentVelocity2?.z() + averageAcceleration.z()
          );
          m2Body.setLinearVelocity(newVelocity2);

          lastActivityTime = Date.now();
        });

        // ---------------------------------------MEDAL RETURN BACK-----------------------------
        // Функция для проверки бездействия и возвращения медали в исходное положение
        function checkIdleAndReturnToInitial() {
          if (Date.now() - lastActivityTime > idleThreshold) {
            // Медаль не трогали в течение достаточного времени, возвращаем её в исходное положение

            var currentPosition = medalBody?.getWorldTransform().getOrigin();

            // Вычисляем ускорение, направленное к исходной позиции
            var accelerationToInitial = new Ammo.btVector3(
              (initialPosition.x() - currentPosition?.x()) * 0.1, // Направляем ускорение к исходной позиции с учетом плавного изменения
              (initialPosition.y() - currentPosition?.y()) * 0.1,
              (initialPosition.z() - currentPosition?.z()) * 0.1
            );

            // Применяем ускорение к медали
            var currentVelocity = medalBody?.getLinearVelocity();
            var newVelocity = new Ammo.btVector3(
              accelerationToInitial.x(),
              accelerationToInitial.y(),
              accelerationToInitial.z()
            );
            medalBody?.setLinearVelocity(newVelocity);
          }

          // Повторяем проверку через короткий интервал времени
          setTimeout(checkIdleAndReturnToInitial, 3000);
        }

        checkIdleAndReturnToInitial();
      }

      function animate() {
        requestAnimationFrame(animate);
        // controls.update();
        render();
      }

      function render() {
        const deltaTime = clock.getDelta();

        updatePhysics(deltaTime);

        renderer.render(scene, camera);
      }

      function updatePhysics(deltaTime) {
        // Hinge control
        // Step world
        physicsWorld.stepSimulation(deltaTime, 60);

        // Update rope
        const softBody = rope?.userData.physicsBody;

        const ropePositions = rope?.geometry.attributes.position.array;
        const numVerts = ropePositions?.length / 3;

        const nodes = softBody?.get_m_nodes();
        let indexFloat = 0;

        for (let i = 0; i < numVerts; i++) {
          const node = nodes.at(i);
          const nodePos = node.get_m_x();
          ropePositions[indexFloat++] = nodePos.x();
          ropePositions[indexFloat++] = nodePos.y();
          ropePositions[indexFloat++] = nodePos.z();
        }

        if (rope) {
          rope.geometry.attributes.position.needsUpdate = true;
        }

        // if (medal) {
        //   const nodes = softBody?.get_m_nodes();
        //   let indexFloat = 0;
        //   const node = nodes.at(numVerts - 1);
        //   const nodePos = node.get_m_x();
        //   medal.scene.position.set(nodePos.x(), nodePos.y(), nodePos.z());
        // }

        // Update rigid bodies
        for (let i = 0, il = rigidBodies.length; i < il; i++) {
          const objThree = rigidBodies[i];
          const objPhys = objThree.userData.physicsBody;
          const ms = objPhys.getMotionState();
          if (ms) {
            ms.getWorldTransform(transformAux1);
            const p = transformAux1.getOrigin();
            const q = transformAux1.getRotation();
            objThree.position.set(p.x(), p.y(), p.z());
            objThree.quaternion.set(q.x(), q.y(), q.z(), q.w());
          }
        }
      }
    </script>
  </body>
</html>
